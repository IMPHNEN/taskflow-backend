"""
GitHub setup service for setting up project repositories.
"""
import json
import logging
import re
import asyncio
import aiohttp
import datetime
from typing import Dict, Any
from pydantic import BaseModel, Field
from github import Github

from agno.agent import Agent
from agno.models.groq import Groq
from agno.models.google import Gemini
from agno.models.openai import OpenAIChat
from agno.models.mistral import MistralChat
from agno.memory.v2.schema import UserMemory

from app.services.memory_storage_service import get_memory, get_storage

from .config import (
    GITHUB_MODEL_TYPE,
    GITHUB_MODEL_ID,
    ENABLE_DEBUG_MODE,
    ENABLE_SHOW_TOOL_CALLS,
    ENABLE_MARKDOWN,
)

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Constants
CREDITS = "Created by TaskFlow"

class RepositoryContent(BaseModel):
    """Schema for repository content generated by AI"""
    description: str = Field(
        ..., 
        description="A concise description of the repository (max 160 chars)"
    )
    readme_content: str = Field(
        ...,
        description="Complete README content in markdown format"
    )

class GitHubSetupService:
    """Service for setting up GitHub repositories."""

    def __init__(self, model_type: str = None, model_id: str = None):
        """
        Initialize the GitHub Setup service.
        
        Args:
            model_type: The model provider to use ('groq', 'gemini', 'openai', or 'mistral')
            model_id: The model ID to use
        """
        self.model_type = model_type or GITHUB_MODEL_TYPE
        self.model_id = model_id or GITHUB_MODEL_ID
        
        # Initialize the model based on provider
        if self.model_type.lower() == "gemini":
            self.model = Gemini(id=self.model_id)
        elif self.model_type.lower() == "openai":
            self.model = OpenAIChat(id=self.model_id)
        elif self.model_type.lower() == "mistral":
            self.model = MistralChat(id=self.model_id)
        else:  # Default to groq
            self.model = Groq(id=self.model_id)

        # Initialize Memory and Storage using singleton service
        self.memory = get_memory()
        self.storage = get_storage()

        self.agent = Agent(
            model=self.model,
            memory=self.memory,
            enable_agentic_memory=True,
            enable_user_memories=True,
            storage=self.storage,
            name="GitHubSetup",
            description="A technical writer specialized in creating comprehensive GitHub repository documentation based on PRD content",
            instructions=f"""
            You are TaskFlow's GitHub repository setup expert. Your role is to:
            1. Create well-structured repositories for projects
            2. Set up proper project documentation
            3. Configure repository settings and labels
            4. Create initial project structure
            
            Follow these guidelines:
            1. Create clear, professional documentation
            2. Set up proper project structure based on the tech stack
            3. Configure meaningful labels and milestones
            4. Ensure all setup follows GitHub best practices
            
            README sections to include (in order):
            # [Project Name]
            1. üéØ Project Title and Description
               - Brief introduction
               - Project objectives
               - Target completion timeline
            
            2. üë• Target Users
               - List primary user groups
               - Key user characteristics
               - User requirements
            
            3. üåü Key Features
               - List high-priority features
               - Include priority level
               - Brief description of each feature
               - User stories or acceptance criteria if provided
            
            4. üîß Technical Overview
               - Architecture components
               - Technology stack
               - Infrastructure requirements
            
            5. ‚öôÔ∏è Non-Functional Requirements
               - Performance metrics
               - Security requirements
               - Scalability requirements
               - Other relevant NFRs from PRD
            
            6. üìä Project Scope
               - Budget information (if public)
               - Team composition
               - Project timeline
               - Key limitations or constraints
            
            7. ‚úÖ Acceptance Criteria
               - Key success metrics
               - Required certifications
               - Testing requirements
            
            Important guidelines:
            - Include ONLY information present in the PRD
            - Maintain the same level of detail as the PRD
            - Keep technical specifications if mentioned
            - Exclude implementation details unless specified in PRD
            - Do NOT add speculative information
            - Do NOT include setup/installation unless in PRD

            Required Output Format:
            You must respond with a JSON object that matches this Pydantic model schema:
            {RepositoryContent.model_json_schema()}
            
            Focus on information valuable to stakeholders and project starters.
            Include ONLY information that is present in the PRD.
            Do NOT include setup, usage, license, or contact information.
            """,
            add_datetime_to_instructions=True,
            show_tool_calls=ENABLE_SHOW_TOOL_CALLS,
            debug_mode=ENABLE_DEBUG_MODE,
            markdown=ENABLE_MARKDOWN
        )
            
        logger.info(f"Initialized GitHub Setup with {self.model_type} model (ID: {self.model_id})")

    def extract_json_from_response(self, response_content: str) -> str:
        """Extract JSON content from markdown code blocks"""
        json_matches = list(re.finditer(r"```(?:json)?([\s\S]*?)```", response_content, re.MULTILINE))
        if json_matches:
            # Use the last match
            return json_matches[-1].group(1).strip()
        return response_content.strip()

    async def generate_repo_content(self, repo_name: str, prd_content: str, project_id: str = None) -> RepositoryContent:
        """Generate repository content from PRD"""
        prompt = f"""
        Please analyze this PRD and generate stakeholder-focused repository content for '{repo_name}':
        ```markdown
        {prd_content}
        ```
        """

        response = await self.agent.arun(
            prompt,
            user_id=project_id,
            session_id=f"{project_id}_brd" if project_id else None            
        )
        if not response or not response.content:
            raise ValueError("Failed to generate repository content")
            
        try:
            # Parse the JSON response
            if isinstance(response.content, str):
                # Extract JSON from markdown code blocks if present
                json_content = self.extract_json_from_response(response.content)
                content_dict = json.loads(json_content)
                return RepositoryContent(**content_dict)
            elif isinstance(response.content, RepositoryContent):
                return response.content
            else:
                raise ValueError(f"Unexpected response type: {type(response.content)}")
        except Exception as e:
            raise ValueError(f"Failed to parse agent response: {str(e)}")

    async def create_or_update_readme(self, repo, content: str):
        """Create or update README file"""
        try:
            # Append TaskFlow credits to README
            content_with_credits = f"{content}\n\n# üèÜ Credits\n\n**{CREDITS}**"
            try:
                contents = repo.get_contents("README.md")
                repo.update_file("README.md", "Update README", content_with_credits, contents.sha)
            except:
                repo.create_file("README.md", "Add README", content_with_credits)
            logger.info("‚úÖ README created/updated")
        except Exception as e:
            logger.error(f"‚ùå Failed to create/update README: {str(e)}")
            raise

    async def create_labels(self, repo):
        """Create project labels"""
        labels = {
            "epic": {"color": "E53935", "description": "High-level category"},
            "feature": {"color": "1E88E5", "description": "Mid-level component"},
            "task": {"color": "43A047", "description": "Specific work item"}
        }
        
        try:
            existing_labels = {label.name: label for label in repo.get_labels()}
            for name, props in labels.items():
                if name not in existing_labels:
                    repo.create_label(name=name, color=props["color"], description=props["description"])
            logger.info("‚úÖ Labels created")
        except Exception as e:
            logger.error(f"‚ùå Failed to create labels: {str(e)}")
            raise

    async def create_github_item(self, repo, item, item_type, milestone_map=None):
        """Generic function to create GitHub items (milestones, issues)"""
        try:
            if item_type == "milestone":
                description = f"{item['description']}\n[{CREDITS}]"
                result = repo.create_milestone(title=item["title"], description=description)
            else:
                description = f"{item['description']}\n[{CREDITS}]"
                kwargs = {
                    "title": item["title"],
                    "body": description,
                    "labels": [item_type]
                }
                if item_type == "feature" and milestone_map:
                    if milestone := milestone_map.get(item.get("parent_id")):
                        kwargs["milestone"] = milestone
                result = repo.create_issue(**kwargs)
            
            return item["id"], result
        except Exception as e:
            logger.error(f"‚ùå Failed to create {item_type}: {str(e)}")
            return None

    async def create_items_in_batches(self, repo, items, item_type, milestone_map=None, batch_size=5):
        """Generic function to create GitHub items in batches"""
        if not items:
            return {}
            
        logger.info(f"üî® Creating {len(items)} {item_type}s in batches...")
        batches = [items[i:i + batch_size] for i in range(0, len(items), batch_size)]
        
        item_map = {}
        for i, batch in enumerate(batches, 1):
            logger.info(f"üì¶ Processing {item_type} batch {i}/{len(batches)} ({len(batch)} items)...")
            
            # Process batch with asyncio.gather
            batch_results = await asyncio.gather(
                *(self.create_github_item(repo, item, item_type, milestone_map) for item in batch)
            )
            
            # Add successful results to the map
            item_map.update({id_: item for id_, item in batch_results if id_ is not None})
            
            # Add delay between batches
            if i < len(batches):
                logger.info(f"‚è≥ Waiting between {item_type} batches...")
                await asyncio.sleep(0.5)
        
        logger.info(f"‚ú® Created {len(item_map)} {item_type}s successfully")
        return item_map

    async def link_task_to_feature(self, session, repo, github_token, parent_issue, child_issue):
        """Link a single task to its parent feature using sub-issues API"""
        url = f"https://api.github.com/repos/{repo.full_name}/issues/{parent_issue.number}/sub_issues"
        headers = {
            "Accept": "application/vnd.github+json",
            "Authorization": f"Bearer {github_token}",
            "X-GitHub-Api-Version": "2022-11-28"
        }
        payload = {"sub_issue_id": child_issue.id}
        
        try:
            async with session.post(url, headers=headers, json=payload) as response:
                if response.status == 422:
                    logger.warning(f"‚ö†Ô∏è  Skipping link for task {child_issue.title} (might already be linked)")
                    return True
                response.raise_for_status()
                return True
        except Exception as e:
            logger.error(f"‚ùå Failed to link task {child_issue.title} to feature {parent_issue.title}: {str(e)}")
            return False

    async def link_tasks_to_features(self, repo, github_token, tasks, issue_map, batch_size=5):
        """Link tasks to features using sub-issues API with batching"""
        async with aiohttp.ClientSession() as session:
            # Filter tasks that need linking
            tasks_to_link = [
                task for task in tasks 
                if task.get("parent_id") in issue_map and task["id"] in issue_map
            ]
            
            if not tasks_to_link:
                return 0, 0
                
            logger.info(f"üîó Linking {len(tasks_to_link)} tasks to features in batches...")
            batches = [tasks_to_link[i:i + batch_size] for i in range(0, len(tasks_to_link), batch_size)]
            
            all_results = []
            for i, batch in enumerate(batches, 1):
                logger.info(f"üì¶ Processing batch {i}/{len(batches)} ({len(batch)} tasks)...")
                
                # Process each task in the batch
                batch_results = await asyncio.gather(
                    *(self.link_task_to_feature(
                        session, repo, github_token,
                        issue_map[task["parent_id"]],
                        issue_map[task["id"]]
                    ) for task in batch)
                )
                all_results.extend(batch_results)
                
                # Add delay between batches
                if i < len(batches):
                    logger.info("‚è≥ Waiting between batches...")
                    await asyncio.sleep(0.5)
            
            success = sum(1 for r in all_results if r)
            failed = len(all_results) - success
            logger.info(f"‚úÖ Successfully linked {success} tasks, {failed} failed")
            return success, failed

    async def setup_repository(
        self, 
        project_details: Dict[str, Any], 
        prd_content: str,
        github_token: str,
        project_id: str = None
    ) -> Dict[str, Any]:
        """
        Set up a GitHub repository for the project.
        
        Args:
            project_details: Dictionary containing project information
            prd_content: PRD content in markdown format
            github_token: GitHub access token
            project_id: Optional project ID for tracking
            
        Returns:
            Dictionary with setup results
            
        Raises:
            ValueError: If repository setup fails
        """
        logger.info(f"Setting up GitHub repository for: {project_details.get('name', 'Unnamed Project')}")
        
        try:
            # Convert tasks to JSON format
            tasks_json = project_details.get('tasks_generated', [])
            
            # Init GitHub client
            gh = Github(github_token)
            user = gh.get_user()
            
            # Process and sort tasks by type
            tasks_by_type = {
                "epic": sorted([t for t in tasks_json if t.get("task_type") == "epic"], key=lambda x: x.get("position", 999)),
                "feature": sorted([t for t in tasks_json if t.get("task_type") == "feature"], key=lambda x: x.get("position", 999)),
                "task": sorted([t for t in tasks_json if t.get("task_type") == "task"], key=lambda x: x.get("position", 999))
            }
            
            # Generate repository name with sanitized project name and timestamp
            safe_name = re.sub(r'-+', '-', re.sub(r'[^a-zA-Z0-9]', '-', project_details.get('name', 'project'))[:10]).strip('-').lower()
            repo_name = f"{safe_name}-taskflow-{int(datetime.datetime.now().timestamp())}"
            
            # Generate repository content
            logger.info("ü§ñ Generating repository content with AI...")
            repo_content = await self.generate_repo_content(repo_name, prd_content or "No PRD provided", project_id)
            self.memory.add_user_memory(user_id=project_id, memory=UserMemory(
                memory=f"""
                Repository Content:
                ```markdown
                {repo_content.readme_content}
                ```
                """,
                topics=["Repository Content", "GitHub Repository Setup"]
            ))
            
            
            # Create repository
            repo = user.create_repo(
                name=repo_name,
                description=repo_content.description,
                private=False,
                auto_init=False
            )
            logger.info(f"üéâ Created new repository: {repo.html_url}")
            
            logger.info("\nüöÄ Setting up project components in parallel...")
            
            # Phase 1: Create labels first (required for all issues)
            logger.info("üìã Phase 1: Setting up labels...")
            await self.create_labels(repo)
            
            # Phase 2: Create milestones and README in parallel
            logger.info("\nüìã Phase 2: Setting up milestones and README...")
            readme_task = self.create_or_update_readme(repo, repo_content.readme_content)
            milestone_task = self.create_items_in_batches(repo, tasks_by_type["epic"], "milestone")
            
            _, milestone_map = await asyncio.gather(readme_task, milestone_task)
            
            # Phase 3: Create feature and task issues in parallel
            logger.info("\nüìã Phase 3: Creating feature and task issues in parallel...")
            feature_task = self.create_items_in_batches(repo, tasks_by_type["feature"], "feature", milestone_map)
            task_task = self.create_items_in_batches(repo, tasks_by_type["task"], "task")
            
            feature_map, task_map = await asyncio.gather(feature_task, task_task)
            
            # Combine issue maps
            issue_map = {**feature_map, **task_map}
            
            # Phase 4: Link tasks to features
            logger.info("\nüìã Phase 4: Linking tasks to features...")
            success, failed = await self.link_tasks_to_features(repo, github_token, tasks_by_type["task"], issue_map)
            
            logger.info(f"‚úÖ Successfully set up repository: {repo.html_url}")
            return {
                "status": "success",
                "repository_url": repo.html_url,
                "repository_name": repo.name,
                "description": repo_content.description,
                "stats": {
                    "milestones": len(milestone_map),
                    "features": len(feature_map),
                    "tasks": len(task_map),
                    "links_successful": success,
                    "links_failed": failed
                }
            }
                
        except Exception as e:
            logger.error(f"‚ùå Repository setup failed: {str(e)}")
            return {
                "status": "error",
                "error": str(e)
            } 